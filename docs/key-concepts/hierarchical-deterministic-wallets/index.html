<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Recovery Phrases Motivation We define a way for easily entering and writing down arbitrary binary seeds using a simple dictionary of known words (available in many different languages).
The motivation here is to have sentence of words easy to read and write for humans, which map uniquely back and forth to a sized binary data (harder to remember).
Encoding The process describing how to encode recovery phrases is described in BIP-0039 section &ldquo;Generating the mnemonic&rdquo;."><meta property="og:title" content="HD Wallets"><meta property="og:description" content="Recovery Phrases Motivation We define a way for easily entering and writing down arbitrary binary seeds using a simple dictionary of known words (available in many different languages).
The motivation here is to have sentence of words easy to read and write for humans, which map uniquely back and forth to a sized binary data (harder to remember).
Encoding The process describing how to encode recovery phrases is described in BIP-0039 section &ldquo;Generating the mnemonic&rdquo;."><meta property="og:type" content="article"><meta property="og:url" content="https://input-output-hk.github.io/adrestia/docs/key-concepts/hierarchical-deterministic-wallets/"><meta property="article:modified_time" content="2021-11-03T15:25:56+08:00"><title>HD Wallets | Adrestia User-Guide</title><link rel=icon href=/adrestia/favicon.png type=image/x-icon><link rel=stylesheet href=/adrestia/book.min.14992ab10882725ec3ec1a83d983a7deea4ea3dad5a7471c76e0878489b63762.css integrity="sha256-FJkqsQiCcl7D7BqD2YOn3upOo9rVp0ccduCHhIm2N2I="><script defer src=/adrestia/en.search.min.5c13ca197293f6339a3cb559319090a4fc99b80272ab1b35e8be1f05565d09ff.js integrity="sha256-XBPKGXKT9jOaPLVZMZCQpPyZuAJyqxs16L4fBVZdCf8="></script></head><body><input type=checkbox class=hidden id=menu-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/adrestia><span>Adrestia User-Guide</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/adrestia/docs/architecture/>Architecture</a></li><li><a href=/adrestia/docs/installation/>Installation Instructions</a></li><li><span>Common Use-Cases</span><ul><li><a href=/adrestia/docs/common-use-cases/how-to-create-a-wallet/>How to create a wallet</a></li><li><a href=/adrestia/docs/common-use-cases/how-to-manage-wallets/>How to manage wallets</a></li><li><a href=/adrestia/docs/common-use-cases/how-to-create-addresses/>How to "create" addresses</a></li><li><a href=/adrestia/docs/common-use-cases/how-to-make-a-transaction/>How to make a transaction</a></li></ul></li><li><span>Key Concepts</span><ul><li><a href=/adrestia/docs/key-concepts/utxo/>UTxO</a></li><li><a href=/adrestia/docs/key-concepts/hierarchical-deterministic-wallets/ class=active>HD Wallets</a></li><li><a href=/adrestia/docs/key-concepts/addresses-byron/>Addresses Format (Byron)</a></li></ul></li><li><a href=/adrestia/docs/api-references/>API References</a></li><li><a href=/adrestia/docs/faq/>FAQ</a></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/adrestia/svg/menu.svg class=book-icon alt=Menu></label>
<strong>HD Wallets</strong>
<label for=toc-control><img src=/adrestia/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><input type=checkbox class=hidden id=toc-control><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#recovery-phrases>Recovery Phrases</a><ul><li><a href=#motivation>Motivation</a></li><li><a href=#encoding>Encoding</a></li><li><a href=#dictionaries>Dictionaries</a></li></ul></li><li><a href=#hierarchical-deterministic-wallets>Hierarchical Deterministic Wallets</a><ul><li><a href=#motivation-1>Motivation</a></li><li><a href=#notation>Notation</a></li><li><a href=#path-levels>Path Levels</a></li><li><a href=#account-discovery>Account Discovery</a></li><li><a href=#address-gap-limit>Address gap limit</a></li></ul></li><li><a href=#master-key-generation>Master Key Generation</a><ul><li><a href=#history>History</a></li><li><a href=#overview>Overview</a></li><li><a href=#pseudo-code>Pseudo-code</a></li></ul></li></ul></nav></aside></header><article class=markdown><h2 id=recovery-phrases>Recovery Phrases</h2><h3 id=motivation>Motivation</h3><p>We define a way for easily entering and writing down arbitrary binary seeds using a simple dictionary of known words (available in many different languages).</p><p>The motivation here is to have sentence of words easy to read and write for humans, which map uniquely back and forth to a sized binary data (harder to remember).</p><h3 id=encoding>Encoding</h3><p>The process describing how to encode recovery phrases is described in <a href=https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki>BIP-0039</a> section &ldquo;Generating the mnemonic&rdquo;. Below is a reformulation of this specification.</p><p>We call <em>Entropy</em> an arbitrary sequence of bytes that has been generated through high quality randomness methods. The allowed size of <em>Entropy</em> is 96-256 bits and is necessarily a multiple of 32 bits (4 bytes).</p><p>A checksum is appended to the initial entropy by taking the first <code>ENT / 32</code> bits of the <code>SHA256</code> hash of it, where <code>ENT</code> designates the <em>Entropy</em> size in bits.</p><p>Then, the concatenated result is split into groups of 11 bits, each encoding a number from 0 to 2047 serving as an index into a known dictionary (see below).</p><table><thead><tr><th>Sentence Length</th><th>Entropy Size</th><th>Checksum Size</th></tr></thead><tbody><tr><td>9 words</td><td>96 bits (12 bytes)</td><td>3 bits</td></tr><tr><td>12 words</td><td>128 bits (16 bytes)</td><td>4 bits</td></tr><tr><td>15 words</td><td>160 bits (20 bytes)</td><td>5 bits</td></tr><tr><td>18 words</td><td>192 bits (24 bytes)</td><td>6 bits</td></tr><tr><td>21 words</td><td>224 bits (28 bytes)</td><td>7 bits</td></tr><tr><td>24 words</td><td>256 bits (32 bytes)</td><td>8 bits</td></tr></tbody></table><h3 id=dictionaries>Dictionaries</h3><p>Cardano uses the same dictionaries as defined in <a href=https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md>BIP-0039</a>.</p><hr><h2 id=hierarchical-deterministic-wallets>Hierarchical Deterministic Wallets</h2><h3 id=motivation-1>Motivation</h3><p>In Cardano, hierarchical deterministic (abbrev. HD) wallets are similar to those described in <a href=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#motivation>BIP-0032</a>.</p><p>Deterministic wallets and elliptic curve mathematics permit schemes where one can calculate a wallet public keys without revealing its private keys. This permits for example a webshop business to let its webserver generate fresh addresses (public key hashes) for each order or for each customer, without giving the webserver access to the corresponding private keys (which are required for spending the received funds). However, deterministic wallets typically consist of a single &ldquo;chain&rdquo; of keypairs. The fact that there is only one chain means that sharing a wallet happens on an all-or-nothing basis.</p><p>However, in some cases one only wants some (public) keys to be shared and recoverable. In the example of a webshop, the webserver does not need access to all public keys of the merchant&rsquo;s wallet; only to those addresses which are used to receive customer&rsquo;s payments, and not for example the change addresses that are generated when the merchant spends money. Hierarchical deterministic wallets allow such selective sharing by supporting multiple keypair chains, derived from a single root.</p><h3 id=notation>Notation</h3><p>Conceptually, HD derivation can be seen as a tree with many branches, where keys live at each node and leaf such that an entire sub-tree can be recovered from only a parent key (and seemingly, the whole tree can be recovered from the root master key).</p><p>For deriving new keys from parent keys, we use the same approach as defined in <a href=/adrestia/user-guide/Ed25519_BIP.pdf>BIP32-Ed25519: Hierarchical Deterministic Keys over a Non-linear Keyspace</a>.</p><p>We note
<link rel=stylesheet href=/adrestia/katex/katex.min.css><script defer src=/adrestia/katex/katex.min.js></script><script defer src=/adrestia/katex/auto-render.min.js onload=renderMathInElement(document.body);></script><span>\(CKD_{priv}\)</span>
the derivation of a private child key from a parent private key such that:</p><span>\(CKD_{prv}((k^P, c^P), i) → (k_i, c_i)\)</span><p>We note <span>\(CKD_{pub}\)</span>
the derivation of a public child key from a parent public key such that:</p><span>\(i &lt; 2^{31}: CKD_{pub}((A^P, c^P), i) → (A_i, c_i)\)</span><blockquote class="book-hint info">This is only possible for so-called &ldquo;soft&rdquo; derivation indexes, smaller than <span>(2^{31})</span>
.</blockquote><p>We note <span>\(N\)</span>
the public key corresponding to a private key such that:</p><span>\(N(k, c) → (A, c) \)</span><p>To shorten notation, we will borrow the same notation as described in BIP-0032
and write <span>\(CKD_{priv}(CKD_{priv}(CKD_{priv}(m,3H),2),5)\)</span>
as <code>m/3H/2/5</code>. Equivalently for
public keys, we write <span>\(CKD_{pub}(CKD_{pub}(CKD_{pub}(M,3),2),5)\)</span>
as <code>M/3/2/5</code>.</p><h3 id=path-levels>Path Levels</h3><p>Cardano wallet defines the following path levels:</p><span>\(m / purpose_H / coin\_type_H / account_H / account\_type / address\_index\)</span><ul><li><span>\(purpose_H\)</span>
is set to <span>\(1852_H\)</span></li><li><span>\(coin\_type_H\)</span>
is set to <span>\(1815_H\)</span></li><li><span>\(account_H\)</span>
is set for now to <span>\(0_H\)</span></li><li><span>\(account\_type\)</span>
is either:<ul><li><code>0</code> to indicate an address on the external chain, that is, an address
that is meant to be public and communicated to other users.</li><li><code>1</code> to indicate an address on the internal chain, that is, an address
that is meant for change, generated by a wallet software.</li><li><code>2</code> to indicate a reward account address, used for delegation.</li></ul></li><li><span>\(address\_index\)</span>
is either:<ul><li><code>0</code> if the <span>\(account\_type\)</span>
is <code>2</code></li><li>Anything between 0 and 2<sup>31 otherwise</li></ul></li></ul><blockquote class="book-hint warning">In the <em>Byron</em> era, sequential wallets used in Yoroi (a.k.a Icarus wallets) have been using <code>purpose = 44_H</code> according to standard BIP-44 wallets.
The <em>Shelley</em> era introduces however an extension to BIP-44, and therefore, uses a different <code>purpose</code> number.</blockquote><h3 id=account-discovery>Account Discovery</h3><blockquote><p>What follows is taken from the &ldquo;Account Discovery&rdquo; section from <a href=https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account-discovery>BIP-0044</a></p></blockquote><p>When the master seed is imported from an external source the software should start to discover the accounts in the following manner:</p><ul><li>derive the first account&rsquo;s node (index = 0)</li><li>derive the external chain node of this account</li><li>scan addresses of the external chain; respect the gap limit described below</li><li>if no transactions are found on the external chain, stop discovery</li><li>if there are some transactions, increase the account index and go to step 1</li></ul><p>For the algorithm to be successful, software should disallow creation of new accounts if previous one has no transaction history.</p><p>Please note that the algorithm works with the transaction history, not account balances, so you can have an account with 0 total coins and the algorithm will still continue with discovery.</p><h3 id=address-gap-limit>Address gap limit</h3><p>Address gap limit is currently set to 20. If the software hits 20 unused addresses in a row, it expects there are no used addresses beyond this point and stops searching the address chain. We scan just the external chains, because internal chains receive only coins that come from the associated external chains.</p><p>Wallet software should warn when the user is trying to exceed the gap limit on an external chain by generating a new address.</p><h2 id=master-key-generation>Master Key Generation</h2><h3 id=history>History</h3><p>Throughout the years, Cardano has been using different styles of HD wallets.
We categorize these wallets in the following terms:</p><table><thead><tr><th>Wallet Style</th><th>Compatible Products</th></tr></thead><tbody><tr><td>Byron</td><td>Daedalus, Yoroi</td></tr><tr><td>Icarus</td><td>Yoroi, Trezor</td></tr><tr><td>Ledger</td><td>Ledger</td></tr></tbody></table><p>Each wallet is based on Ed25519 elliptic curves though differs in subtle ways
highlighted in the next sections.</p><h3 id=overview>Overview</h3><p>The master key generation is the mean by which on turns an initial entropy into
a secure cryptographic key. Child keys can be derived from a master key to produce
an HD structure as outlined above. Child key derivation is explored in next sections.</p><p>In Cardano, the master key generation is different depending on which style of wallet
one is considering. In each case however, the generation is a function from an initial
seed to an extended private key (abbrev. XPrv) composed of:</p><ul><li>64 bytes: an extended Ed25519 secret key composed of:<ul><li>32 bytes: Ed25519 curve scalar from which few bits have been tweaked (see below)</li><li>32 bytes: Ed25519 binary blob used as IV for signing</li></ul></li><li>32 bytes: chain code for allowing secure child key derivation</li></ul><blockquote><p>Additional resources:</p><ul><li><a href=https://github.com/satoshilabs/slips/blob/master/slip-0010.md>SLIP 0010</a></li><li><a href=https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki>BIP 0032</a></li><li><a href=https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki>BIP 0039</a></li><li><a href=https://tools.ietf.org/html/rfc8032#section-5.1.5>RFC 8032</a></li></ul></blockquote><h3 id=pseudo-code>Pseudo-code</h3><div class=book-tabs><input type=radio class=hidden name=tabs-pseudo-code id=tabs-pseudo-code-0 checked>
<label for=tabs-pseudo-code-0>Byron</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>generateMasterKey</span>(<span style=color:#a6e22e>seed</span>) {
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hashRepeatedly</span>(<span style=color:#a6e22e>seed</span>, <span style=color:#ae81ff>1</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hashRepeatedly</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>i</span>) {
    (<span style=color:#a6e22e>iL</span>, <span style=color:#a6e22e>iR</span>) <span style=color:#f92672>=</span> <span style=color:#a6e22e>HMAC</span>
        ( <span style=color:#a6e22e>hash</span><span style=color:#f92672>=</span><span style=color:#a6e22e>SHA512</span>
        , <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span><span style=color:#a6e22e>key</span>
        , <span style=color:#a6e22e>message</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;Root Seed Chain &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>UTF8NFKD</span>(<span style=color:#a6e22e>i</span>)
        );
    
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>prv</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>tweakBits</span>(<span style=color:#a6e22e>SHA512</span>(<span style=color:#a6e22e>iL</span>));

    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>prv</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0b0010</span><span style=color:#a6e22e>_0000</span>) { 
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hashRepeatedly</span>(<span style=color:#a6e22e>key</span>, <span style=color:#a6e22e>i</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>);
    }

    <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>prv</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>iR</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>tweakBits</span>(<span style=color:#a6e22e>data</span>) {
    <span style=color:#75715e>// * clear the lowest 3 bits
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * clear the highest bit
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * set the highest 2nd bit
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>]  <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0b1111</span><span style=color:#a6e22e>_1000</span>;
    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0b0111</span><span style=color:#a6e22e>_1111</span>;
    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0b0100</span><span style=color:#a6e22e>_0000</span>;

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>;
}
</code></pre></div></div><input type=radio class=hidden name=tabs-pseudo-code id=tabs-pseudo-code-1>
<label for=tabs-pseudo-code-1>Icarus</label><div class="book-tabs-content markdown-inner"><p><em>Icarus</em> master key generation style supports setting an extra password as an arbitrary
byte array of any size. This password acts as a second factor applied to cryptographic key
retrieval. When the seed comes from an encoded recovery phrase, the password can therefore
be used to add extra protection in case where the recovery phrase were to be exposed.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>generateMasterKey</span>(<span style=color:#a6e22e>seed</span>, <span style=color:#a6e22e>password</span>) {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>PBKDF2</span>
        ( <span style=color:#a6e22e>kdf</span><span style=color:#f92672>=</span><span style=color:#a6e22e>HMAC</span><span style=color:#f92672>-</span><span style=color:#a6e22e>SHA512</span>
        , <span style=color:#a6e22e>iter</span><span style=color:#f92672>=</span><span style=color:#ae81ff>4096</span>
        , <span style=color:#a6e22e>salt</span><span style=color:#f92672>=</span><span style=color:#a6e22e>seed</span>
        , <span style=color:#a6e22e>password</span><span style=color:#f92672>=</span><span style=color:#a6e22e>password</span>
        , <span style=color:#a6e22e>outputLen</span><span style=color:#f92672>=</span><span style=color:#ae81ff>96</span>
        );

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>tweakBits</span>(<span style=color:#a6e22e>data</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>tweakBits</span>(<span style=color:#a6e22e>data</span>) {
    <span style=color:#75715e>// on the ed25519 scalar leftmost 32 bytes:
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * clear the lowest 3 bits
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * clear the highest bit
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * clear the 3rd highest bit
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * set the highest 2nd bit
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>]  <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0b1111</span><span style=color:#a6e22e>_1000</span>;
    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0b0001</span><span style=color:#a6e22e>_1111</span>;
    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0b0100</span><span style=color:#a6e22e>_0000</span>;

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>;
}
</code></pre></div><blockquote><p>For a detailed analysis of the cryptographic choices and the above requirements,
have a look at: <a href=https://github.com/input-output-hk/chain-wallet-libs/blob/master/doc/CRYPTO.md#master-key-generation-to-cryptographic-key>Wallet Cryptography and Encoding</a></p></blockquote></div><input type=radio class=hidden name=tabs-pseudo-code id=tabs-pseudo-code-2>
<label for=tabs-pseudo-code-2>Ledger</label><div class="book-tabs-content markdown-inner"><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>generateMasterKey</span>(<span style=color:#a6e22e>seed</span>, <span style=color:#a6e22e>password</span>) {
    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>PBKDF2</span>
        ( <span style=color:#a6e22e>kdf</span><span style=color:#f92672>=</span><span style=color:#a6e22e>HMAC</span><span style=color:#f92672>-</span><span style=color:#a6e22e>SHA512</span>
        , <span style=color:#a6e22e>iter</span><span style=color:#f92672>=</span><span style=color:#ae81ff>2048</span>
        , <span style=color:#a6e22e>salt</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mnemonic&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>UTF8NFKD</span>(<span style=color:#a6e22e>password</span>)
        , <span style=color:#a6e22e>password</span><span style=color:#f92672>=</span><span style=color:#a6e22e>UTF8NFKD</span>(<span style=color:#a6e22e>spaceSeparated</span>(<span style=color:#a6e22e>toMnemonic</span>(<span style=color:#a6e22e>seed</span>)))
        , <span style=color:#a6e22e>outputLen</span><span style=color:#f92672>=</span><span style=color:#ae81ff>64</span>
        );

    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>cc</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>HMAC</span>
        ( <span style=color:#a6e22e>hash</span><span style=color:#f92672>=</span><span style=color:#a6e22e>SHA256</span>
        , <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ed25519 seed&#34;</span>
        , <span style=color:#a6e22e>message</span><span style=color:#f92672>=</span><span style=color:#a6e22e>UTF8NFKD</span>(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>seed</span>
        );

    <span style=color:#66d9ef>let</span> (<span style=color:#a6e22e>iL</span>, <span style=color:#a6e22e>iR</span>) <span style=color:#f92672>=</span> <span style=color:#a6e22e>hashRepeatedly</span>(<span style=color:#a6e22e>data</span>);

    <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>tweakBits</span>(<span style=color:#a6e22e>iL</span>) <span style=color:#f92672>+</span> <span style=color:#a6e22e>iR</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>cc</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>hashRepeatedly</span>(<span style=color:#a6e22e>message</span>) {
    <span style=color:#66d9ef>let</span> (<span style=color:#a6e22e>iL</span>, <span style=color:#a6e22e>iR</span>) <span style=color:#f92672>=</span> <span style=color:#a6e22e>HMAC</span>
        ( <span style=color:#a6e22e>hash</span><span style=color:#f92672>=</span><span style=color:#a6e22e>SHA512</span>
        , <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;ed25519 seed&#34;</span>
        , <span style=color:#a6e22e>message</span><span style=color:#f92672>=</span><span style=color:#a6e22e>message</span>
        );
    
    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>iL</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0b0010</span><span style=color:#a6e22e>_0000</span>) { 
        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hashRepeatedly</span>(<span style=color:#a6e22e>iL</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>iR</span>);
    }

    <span style=color:#66d9ef>return</span> (<span style=color:#a6e22e>iL</span>, <span style=color:#a6e22e>iR</span>);
}

<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>tweakBits</span>(<span style=color:#a6e22e>data</span>) {
    <span style=color:#75715e>// * clear the lowest 3 bits
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * clear the highest bit
</span><span style=color:#75715e></span>    <span style=color:#75715e>// * set the highest 2nd bit
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>0</span>]  <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0b1111</span><span style=color:#a6e22e>_1000</span>;
    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>&amp;=</span> <span style=color:#ae81ff>0b0111</span><span style=color:#a6e22e>_1111</span>;
    <span style=color:#a6e22e>data</span>[<span style=color:#ae81ff>31</span>] <span style=color:#f92672>|=</span> <span style=color:#ae81ff>0b0100</span><span style=color:#a6e22e>_0000</span>;

    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>data</span>;
}
</code></pre></div></div></div></article><footer class=book-footer><div class="flex justify-between"><div><a class="flex align-center" href=https://github.com/input-output-hk/adrestia//commit/665b9dda28db9cd7af0e6e12c597918c985a4d60 title="Last modified by Rodney Lorrimar | 2021-03-11" target=_blank rel=noopener><img src=/adrestia/svg/calendar.svg class=book-icon alt=Calendar>
<span>2021-03-11</span></a></div><div><a class="flex align-center" href=https://github.com/input-output-hk/adrestia//edit/master/user-guide/content//docs/key-concepts/hierarchical-deterministic-wallets.md target=_blank rel=noopener><img src=/adrestia/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#recovery-phrases>Recovery Phrases</a><ul><li><a href=#motivation>Motivation</a></li><li><a href=#encoding>Encoding</a></li><li><a href=#dictionaries>Dictionaries</a></li></ul></li><li><a href=#hierarchical-deterministic-wallets>Hierarchical Deterministic Wallets</a><ul><li><a href=#motivation-1>Motivation</a></li><li><a href=#notation>Notation</a></li><li><a href=#path-levels>Path Levels</a></li><li><a href=#account-discovery>Account Discovery</a></li><li><a href=#address-gap-limit>Address gap limit</a></li></ul></li><li><a href=#master-key-generation>Master Key Generation</a><ul><li><a href=#history>History</a></li><li><a href=#overview>Overview</a></li><li><a href=#pseudo-code>Pseudo-code</a></li></ul></li></ul></nav></aside></main></body></html>
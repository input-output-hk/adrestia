'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/adrestia/docs/architecture/','title':"Architecture",'content':"High-Level Diagram   mermaid.initialize({ flowchart: { useMaxWidth:true } });  erDiagram CARDANO-NODE ||--|{ CARDANO-SUBMIT-API : depends-on CARDANO-NODE ||--|{ CARDANO-WALLET : depends-on CARDANO-NODE ||--|{ CARDANO-DB-SYNC : depends-on CARDANO-DB-SYNC ||--|| POSTGRESQL : dumps-into POSTGRESQL ||--|| SMASH : is-queried POSTGRESQL ||--|| CARDANO-GRAPHQL : is-queried POSTGRESQL ||--|| CARDANO-ROSETTA : is-queried CARDANO-GRAPHQL ||--|{ EXPLORER : depends-on SMASH ||--|{ CARDANO-WALLET: connects-to CARDANO-WALLET ||--|{ DAEDALUS : depends-on Components cardano-node The core cardano-node, which participates in the Cardano network, and maintains the state of the Cardano blockchain ledger.\nSupported environments: Linux (64-bits), MacOS (64-bits), Windows (64-bits), Docker  cardano-wallet cardano-wallet An HTTP REST API is recommended for 3rd party wallets and small exchanges who do not want to manage UTxOs for transactions themselves. Use it to send and receive payments from hierarchical deterministic wallets on the Cardano blockchain via HTTP REST or a command-line interface.\nSupported environments: Linux (64-bits), MacOS (64-bits), Windows (64-bits), Docker  cardano-db-sync This application stores blockchain data fetched from cardano-node in a PostgreSQL database to enable higher-level interfaces for blockchain exploration. It powers cardano-graphql.\nSupported environments: Linux (64-bits), MacOS (64-bits), Docker  cardano-graphql A GraphQL API for Cardano, which also serves as the backend of Cardano Explorer.\nSupported environments: Linux (64-bits), MacOS (64-bits), Docker  cardano-submit-api A small HTTP API for submitting transactions to a local cardano-node.\nThe transaction must be fully signed and CBOR-encoded. This could be done by cardano-cli, for example.\ncardano-rosetta Cardano-rosetta is an implementation of the Rosetta specification for Cardano. Rosetta is an open-source specification and set of tools that makes integrating with blockchains simpler, faster, and more reliable.\nNotes See also input-output-hk/adrestia.\n"});index.add({'id':1,'href':'/adrestia/docs/common-use-cases/how-to-create-a-wallet/','title':"How to create a wallet",'content':"Difficulty: beginner\nRequires:\n 📦 cardano-wallet \u0026gt;= v2020-03-11   The easiest and most common way of managing your funds on the Cardano blockchain is through a hierarchical deterministic wallet. One can create a wallet using the following endpoint of cardano-wallet:\nPOST /byron-wallets\nThere are several wallet types available:\n random icarus trezor ledger  The basic difference between them is that for a random wallet user needs to create new address manually, whereas for sequential wallets like icarus, trezor and ledger addresses are generated automatically by the wallet.\nPlease note that random wallets are considered deprecated and should not be used by new applications.  Note also that you can have many wallets being operated by a single cardano-wallet server.\nSee more on HD wallets and addresses.\n"});index.add({'id':2,'href':'/adrestia/docs/key-concepts/utxo/','title':"UTxO",'content':"UTxO In a UTxO-based blockchain, a Transaction is a binding between inputs and outputs.\n input #1 \u0026gt;---* *---\u0026gt; output #1 \\ / input #2 \u0026gt;---*--------* / \\ input #3 \u0026gt;---* *---\u0026gt; output #2 In a standard payment, outputs are a combination of:\n A value A reference (a.k.a address, a \u0026ldquo;proof\u0026rdquo; of ownership telling who owns the output).   input #1 \u0026gt;---* *---\u0026gt; (123, DdzFFzCqr...) \\ / input #2 \u0026gt;---*--------* / \\ input #3 \u0026gt;---* *---\u0026gt; (456, hswdEoQCp...) About address encoding\nWe usually represent addresses as encoded text strings. An address has a structure and a binary representation that is defined by the underlying blockchain. Yet, since they are often used in user-facing interfaces, addresses are usually encoded in a human-friendly format to be easily shared between users.\n An address does not uniquely identify an output. As a matter of fact, multiple transactions could send funds to a same output address! We can however uniquely identify an output by:\n Its host transaction id Its index within that transaction  This combination is also called an input. Said differently, inputs are outputs of previous transactions.\n *---------------- tx#42 ----------------------* | | (tx#14, ix#2) \u0026gt;-----------------* *--\u0026gt; (123, DdzFFqr...)--- (tx#42, ix#0) | \\ / | (tx#41, ix#0) \u0026gt;-----------------*-----* | | / \\ | (tx#04, ix#0) \u0026gt;----------------* *--\u0026gt; (456, hswdQCp...)--- (tx#42, ix#1) | | *---------------------------------------------* Therefore, new transactions spend outputs of previous transactions, and produce new outputs that can be consumed by future transactions. An unspent transaction output (i.e. not used as an input of any transaction) is called a UTxO (as in Unspent Tx Output) and represents an amount of money owned by a participant.\nFAQ  Where does the money come from? How do I make the first transaction? ...  When bootstrapping a blockchain, some initial funds can be distributed among an initial set of stakeholders. This is usually the result of an Initial Coin Offering or, an agreement between multiple parties. In practice it means that, the genesis block of a blockchain may already contain some UTxOs belonging to various stakeholders.\nBeside, core nodes running the protocol and producing blocks are allowed to insert in every block minted (resp. mined) called a coinbase transaction. This transaction has no inputs but follows specific rules fixed by the protocol and is used as an incentive to encourage participants to engage in the protocol.\n    What is the difference between an address and a public key? ...  In a very simple system that would only support payment transactions, public key could be substituted for addresses. In practice, addresses are meant to hold some extra pieces of information that are useful for other aspects of the protocol. For instance, in Cardano in the Shelley era, addresses may also contain:\n  A network discriminant tag, to distinguish addresses between a testNet and the MainNet and avoid unfortunate mistakes.\n  A stake reference to take part in delegation.\n  Addresses may also be used to trigger smart contracts, in which case, they\u0026rsquo;ll refer to a particular script rather than a public key.\nIn a nutshell, a public key is a piece of information that enables a stakeholder to prove one owns a particular UTxO. Whereas an address is a data-structure which contain various pieces of information, for example, a (reference to a) public key.\n    What are Cardano addresses made of? ...  See:\n About Address Format - Byron About Address Format - Shelley     "});index.add({'id':3,'href':'/adrestia/docs/key-concepts/hierarchical-deterministic-wallets/','title':"HD Wallets",'content':"Recovery Phrases Motivation We define a way for easily entering and writing down arbitrary binary seeds using a simple dictionary of known words (available in many different languages).\nThe motivation here is to have sentence of words easy to read and write for humans, which map uniquely back and forth to a sized binary data (harder to remember).\nEncoding The process describing how to encode recovery phrases is described in BIP-0039 section \u0026ldquo;Generating the mnemonic\u0026rdquo;. Below is a reformulation of this specification.\nWe call Entropy an arbitrary sequence of bytes that has been generated through high quality randomness methods. The allowed size of Entropy is 96-256 bits and is necessarily a multiple of 32 bits (4 bytes).\nA checksum is appended to the initial entropy by taking the first ENT / 32 bits of the SHA256 hash of it, where ENT designates the Entropy size in bits.\nThen, the concatenated result is split into groups of 11 bits, each encoding a number from 0 to 2047 serving as an index into a known dictionary (see below).\n   Sentence Length Entropy Size Checksum Size     9 words 96 bits (12 bytes) 3 bits   12 words 128 bits (16 bytes) 4 bits   15 words 160 bits (20 bytes) 5 bits   18 words 192 bits (24 bytes) 6 bits   21 words 224 bits (28 bytes) 7 bits   24 words 256 bits (32 bytes) 8 bits    Dictionaries Cardano uses the same dictionaries as defined in BIP-0039.\n Hierarchical Deterministic Wallets Motivation In Cardano, hierarchical deterministic (abbrev. HD) wallets are similar to those described in BIP-0032.\nDeterministic wallets and elliptic curve mathematics permit schemes where one can calculate a wallet public keys without revealing its private keys. This permits for example a webshop business to let its webserver generate fresh addresses (public key hashes) for each order or for each customer, without giving the webserver access to the corresponding private keys (which are required for spending the received funds). However, deterministic wallets typically consist of a single \u0026ldquo;chain\u0026rdquo; of keypairs. The fact that there is only one chain means that sharing a wallet happens on an all-or-nothing basis.\nHowever, in some cases one only wants some (public) keys to be shared and recoverable. In the example of a webshop, the webserver does not need access to all public keys of the merchant\u0026rsquo;s wallet; only to those addresses which are used to receive customer\u0026rsquo;s payments, and not for example the change addresses that are generated when the merchant spends money. Hierarchical deterministic wallets allow such selective sharing by supporting multiple keypair chains, derived from a single root.\nNotation Conceptually, HD derivation can be seen as a tree with many branches, where keys live at each node and leaf such that an entire sub-tree can be recovered from only a parent key (and seemingly, the whole tree can be recovered from the root master key).\nFor deriving new keys from parent keys, we use the same approach as defined in BIP32-Ed25519: Hierarchical Deterministic Keys over a Non-linear Keyspace.\nWe note  \\(CKD_{priv}\\) the derivation of a private child key from a parent private key such that:\n\\(CKD_{prv}((k^P, c^P), i) → (k_i, c_i)\\) We note \\(CKD_{pub}\\) the derivation of a public child key from a parent public key such that:\n\\(i \u0026lt; 2^{31}: CKD_{pub}((A^P, c^P), i) → (A_i, c_i)\\) This is only possible for so-called \u0026ldquo;soft\u0026rdquo; derivation indexes, smaller than (2^{31}) .  We note \\(N\\) the public key corresponding to a private key such that:\n\\(N(k, c) → (A, c) \\) To shorten notation, we will borrow the same notation as described in BIP-0032 and write \\(CKD_{priv}(CKD_{priv}(CKD_{priv}(m,3H),2),5)\\) as m/3H/2/5. Equivalently for public keys, we write \\(CKD_{pub}(CKD_{pub}(CKD_{pub}(M,3),2),5)\\) as M/3/2/5.\nPath Levels Cardano wallet defines the following path levels:\n\\(m / purpose_H / coin\\_type_H / account_H / account\\_type / address\\_index\\)  \\(purpose_H\\) is set to \\(1852_H\\)  \\(coin\\_type_H\\) is set to \\(1815_H\\)  \\(account_H\\) is set for now to \\(0_H\\)  \\(account\\_type\\) is either:  0 to indicate an address on the external chain, that is, an address that is meant to be public and communicated to other users. 1 to indicate an address on the internal chain, that is, an address that is meant for change, generated by a wallet software. 2 to indicate a reward account address, used for delegation.   \\(address\\_index\\) is either:  0 if the \\(account\\_type\\) is 2 Anything between 0 and 231 otherwise    In the Byron era, sequential wallets used in Yoroi (a.k.a Icarus wallets) have been using purpose = 44_H according to standard BIP-44 wallets. The Shelley era introduces however an extension to BIP-44, and therefore, uses a different purpose number.  Account Discovery  What follows is taken from the \u0026ldquo;Account Discovery\u0026rdquo; section from BIP-0044\n When the master seed is imported from an external source the software should start to discover the accounts in the following manner:\n derive the first account\u0026rsquo;s node (index = 0) derive the external chain node of this account scan addresses of the external chain; respect the gap limit described below if no transactions are found on the external chain, stop discovery if there are some transactions, increase the account index and go to step 1  For the algorithm to be successful, software should disallow creation of new accounts if previous one has no transaction history.\nPlease note that the algorithm works with the transaction history, not account balances, so you can have an account with 0 total coins and the algorithm will still continue with discovery.\nAddress gap limit Address gap limit is currently set to 20. If the software hits 20 unused addresses in a row, it expects there are no used addresses beyond this point and stops searching the address chain. We scan just the external chains, because internal chains receive only coins that come from the associated external chains.\nWallet software should warn when the user is trying to exceed the gap limit on an external chain by generating a new address.\nMaster Key Generation History Throughout the years, Cardano has been using different styles of HD wallets. We categorize these wallets in the following terms:\n   Wallet Style Compatible Products     Byron Daedalus, Yoroi   Icarus Yoroi, Trezor   Ledger Ledger    Each wallet is based on Ed25519 elliptic curves though differs in subtle ways highlighted in the next sections.\nOverview The master key generation is the mean by which on turns an initial entropy into a secure cryptographic key. Child keys can be derived from a master key to produce an HD structure as outlined above. Child key derivation is explored in next sections.\nIn Cardano, the master key generation is different depending on which style of wallet one is considering. In each case however, the generation is a function from an initial seed to an extended private key (abbrev. XPrv) composed of:\n 64 bytes: an extended Ed25519 secret key composed of:  32 bytes: Ed25519 curve scalar from which few bits have been tweaked (see below) 32 bytes: Ed25519 binary blob used as IV for signing   32 bytes: chain code for allowing secure child key derivation   Additional resources:\n SLIP 0010 BIP 0032 BIP 0039 RFC 8032   Pseudo-code Byron function generateMasterKey(seed) { return hashRepeatedly(seed, 1); } function hashRepeatedly(key, i) { (iL, iR) = HMAC ( hash=SHA512 , key=key , message=\u0026#34;Root Seed Chain \u0026#34; + UTF8NFKD(i) ); let prv = tweakBits(SHA512(iL)); if (prv[31] \u0026amp; 0b0010_0000) { return hashRepeatedly(key, i+1); } return (prv + iR); } function tweakBits(data) { // * clear the lowest 3 bits  // * clear the highest bit  // * set the highest 2nd bit  data[0] \u0026amp;= 0b1111_1000; data[31] \u0026amp;= 0b0111_1111; data[31] |= 0b0100_0000; return data; } Icarus Icarus master key generation style supports setting an extra password as an arbitrary byte array of any size. This password acts as a second factor applied to cryptographic key retrieval. When the seed comes from an encoded recovery phrase, the password can therefore be used to add extra protection in case where the recovery phrase were to be exposed.\nfunction generateMasterKey(seed, password) { let data = PBKDF2 ( kdf=HMAC-SHA512 , iter=4096 , salt=seed , password=password , outputLen=96 ); return tweakBits(data); } function tweakBits(data) { // on the ed25519 scalar leftmost 32 bytes:  // * clear the lowest 3 bits  // * clear the highest bit  // * clear the 3rd highest bit  // * set the highest 2nd bit  data[0] \u0026amp;= 0b1111_1000; data[31] \u0026amp;= 0b0001_1111; data[31] |= 0b0100_0000; return data; }  For a detailed analysis of the cryptographic choices and the above requirements, have a look at: Wallet Cryptography and Encoding\n Ledger function generateMasterKey(seed, password) { let data = PBKDF2 ( kdf=HMAC-SHA512 , iter=2048 , salt=\u0026#34;mnemonic\u0026#34; + UTF8NFKD(password) , password=UTF8NFKD(spaceSeparated(toMnemonic(seed))) , outputLen=64 ); let cc = HMAC ( hash=SHA256 , key=\u0026#34;ed25519 seed\u0026#34; , message=UTF8NFKD(1) + seed ); let (iL, iR) = hashRepeatedly(data); return (tweakBits(iL) + iR + cc); } function hashRepeatedly(message) { let (iL, iR) = HMAC ( hash=SHA512 , key=\u0026#34;ed25519 seed\u0026#34; , message=message ); if (iL[31] \u0026amp; 0b0010_0000) { return hashRepeatedly(iL + iR); } return (iL, iR); } function tweakBits(data) { // * clear the lowest 3 bits  // * clear the highest bit  // * set the highest 2nd bit  data[0] \u0026amp;= 0b1111_1000; data[31] \u0026amp;= 0b0111_1111; data[31] |= 0b0100_0000; return data; }  "});index.add({'id':4,'href':'/adrestia/docs/common-use-cases/how-to-manage-wallets/','title':"How to manage wallets",'content':"Difficulty: beginner\nRequires:\n 📦 cardano-wallet \u0026gt;= v2020-04-01   Once you created a wallet you can manage it with cardano-wallet endpoints. There are several operations available.\nList all wallets GET /v2/byron-wallets\nGet specific wallet details GET /v2/byron-wallets/{walletId}\nUpdate wallet metadata PUT /v2/byron-wallets/{walletId}\nUpdate wallet passphrase PUT /v2/byron-wallets/{walletId}/passphrase\nGet wallet UTxO GET /v2/byron-wallets/{walletId}/statistics/utxos\nSee more about UTxO.\nDelete wallet DELETE /v2/byron-wallets/{walletId}\n"});index.add({'id':5,'href':'/adrestia/docs/key-concepts/addresses-byron/','title':"Addresses Format (Byron)",'content':"Internal Structure +-------------------------------------------------------------------------------+ | | | CBOR-Serialized Object with CRC¹ | | | +-------------------------------------------------------------------------------+ | | v +-------------------------------------------------------------------------------+ | Address Root | Address Attributes | AddrType | | | | | | Hash (224 bits) | Der. Path² + Stake + NM | PubKey | (Script) | Redeem | | | (open for extension) | (open for extension) | +-------------------------------------------------------------------------------+ | | | | +----------------------------------+ v | | Derivation Path | +---------------------------+ |----\u0026gt;| | | SHA3-256 | | | ChaChaPoly⁴ AccountIx/AddressIx | | |\u0026gt; Blake2b 224 | | +----------------------------------+ | |\u0026gt; CBOR | | | | | | -AddrType | | +----------------------------------+ | -ASD³ (~AddrType+PubKey) | | | Stake Distribution | | -Address Attributes | | | | +---------------------------+ |----\u0026gt;| BootstrapEra | (Single | Multi) | | +----------------------------------+ | | | +----------------------------------+ | | Network Magic | |----\u0026gt;| | | Addr Discr: MainNet vs TestNet | +----------------------------------+   CRC: Cyclic Redundancy Check; sort of checksum, a bit (pun intended) more reliable.\n  ASD: Address Spending Data; Some data that are bound to an address. It\u0026rsquo;s an extensible object with payload which identifies one of the three elements:\n A Public Key (Payload is thereby a PublicKey) A Script (Payload is thereby a script and its version) A Redeem Key (Payload is thereby a RedeemPublicKey)    Derivation Path: Note that there\u0026rsquo;s no derivation path for Redeem nor Scripts addresses!\n  ChaChaPoly: Authenticated Encryption with Associated Data; See RFC 7539 We use it as a way to cipher the derivation path using a passphrase (the root public key).\n  Example 1: Yoroi Address - Byron Mainnet Let\u0026rsquo;s take an arbitrary Yoroi base58-encoded address of the Byron mainNet:\nAe2tdPwUPEZFRbyhz3cpfC2CumGzNkFBN2L42rcUc2yjQpEkxDbkPodpMAi Now, this address could be represented as a raw bytestring by decoding from base58:\n0X82 0XD8 0X18 0X58 0X21 0X83 0X58 0X1C 0XBA 0X97 0X0A 0XD3 0X66 0X54 0XD8 0XDD 0X8F 0X74 0X27 0X4B 0X73 0X34 0X52 0XDD 0XEA 0XB9 0XA6 0X2A 0X39 0X77 0X46 0XBE 0X3C 0X42 0XCC 0XDD 0XA0 0X00 0X1A 0X90 0X26 0XDA 0X5B In this representation, bytes are in a structured format called CBOR. Some bytes are actually tags which carry a particular semantic, and some are values. We can re-shuffle the bytes as follows to make things a bit clearer:\n82 # array (2) D8 18 # tag (24) [CBOR Metadata] 58 21 (8358...A000) # bytes (33) [Address Payload] 1A 9026DA5B # unsigned(2418465371) [CRC] So, a Byron address is basically formed of two top-level elements:\n A tagged bytestring; 24 means that the bytes represent another CBOR-encoded structure. A CRC of the inner tagged bytestring  Now, if we also interpret the inner bytestring as a CBOR structure, we obtain:\n83 # array(3) 58 1C (BA97...CCDD) # bytes(28) [Address Root] A0 # map(0) [Address Attributes] 00 # unsigned(0) [Address Type] An address type of 0 refers to a spending address for which the address root contains a hash of a public spending key. This address payload has no attribute for the initial address was a Yoroi\u0026rsquo;s address on MainNet which follows a BIP-44 derivation scheme and therefore, does not require any attributes.\nExample 2: Daedalus Address - Byron TestNet Let\u0026rsquo;s take an arbitrary Daedalus base58-encoded address of a Byron testNet:\n37btjrVyb4KEB2STADSsj3MYSAdj52X5FrFWpw2r7Wmj2GDzXjFRsHWuZqrw7zSkwopv8Ci3VWeg6bisU9dgJxW5hb2MZYeduNKbQJrqz3zVBsu9nT Now, this address could be represented as a raw bytestring by decoding from base58:\n0X82 0XD8 0X18 0X58 0X49 0X83 0X58 0X1C 0X9C 0X70 0X85 0X38 0XA7 0X63 0XFF 0X27 0X16 0X99 0X87 0XA4 0X89 0XE3 0X50 0X57 0XEF 0X3C 0XD3 0X77 0X8C 0X05 0XE9 0X6F 0X7B 0XA9 0X45 0X0E 0XA2 0X01 0X58 0X1E 0X58 0X1C 0X9C 0X17 0X22 0XF7 0XE4 0X46 0X68 0X92 0X56 0XE1 0XA3 0X02 0X60 0XF3 0X51 0X0D 0X55 0X8D 0X99 0XD0 0XC3 0X91 0XF2 0XBA 0X89 0XCB 0X69 0X77 0X02 0X45 0X1A 0X41 0X70 0XCB 0X17 0X00 0X1A 0X69 0X79 0X12 0X6C In this representation, bytes are in a structured format called CBOR. Some bytes are actually tags which carry a particular semantic, and some are values. We can re-shuffle the bytes as follows to make things a bit clearer:\n82 # array(2) D8 18 # tag(24) [CBOR Metadata] 58 49 (8358...1700) # bytes(73) [Address Payload] 1A 6979126C # unsigned(1769542252) [CRC] So, a Byron address is basically formed of two top-level elements:\n A tagged bytestring; 24 means that the bytes represent another CBOR-encoded structure. A CRC of the inner tagged bytestring  Now, if we also interpret the inner bytestring as a CBOR structure, we obtain:\n83 # array(3) 58 1C (9C70...450E) # bytes(28) [Address Root] A2 # map(2) [Address Attributes] 01 # unsigned(1) [Derivation Path Attribute] 58 1E (581C...6977) # bytes(30) [Derivation Path Value] 02 # unsigned(2) [Network Magic Attribute] 45 (1A4170CB17) # bytes(5) [Network Magic Value] 00 # unsigned(0) [Address Type] An address type of 0 refers to a spending address for which the address root contains a hash of a public spending key. In addition, we can see that this address has 2 attributes identified by two tags 01 for the derivation path, and 02 for the network magic. The derivation path is an encrypted bytestring which holds two derivation indexes for the account and address paths.\n"});index.add({'id':6,'href':'/adrestia/docs/common-use-cases/how-to-create-addresses/','title':"How to \"create\" addresses",'content':" using cardano-wallet Difficulty: beginner\nRequires:\n 📦 cardano-wallet \u0026gt;= v2020-04-01   Once you have a wallet you can manage your funds. In order to receive a transaction you need to provide an address associated with your wallet to the sender.\nRandom wallets (Legacy Byron) Address creation is only allowed for wallets using random derivation. These are the legacy wallets from cardano-sl.\nFor random wallets user needs to invoke the following wallet endpoint to create new addresses:\nPOST /byron-wallets/{walletId}/addresses\nIn order to list existing addresses another endpoint can be used.\nGET /byron-wallets/{walletId}/addresses\nAlternatively, these endpoints can also be reached from the command-line:\n$ cardano-wallet address create WALLET_ID $ cardano-wallet address list WALLET_ID   Sequential wallets (Icarus \u0026amp; Shelley) Since Icarus, wallets use sequential derivation which must satisfy very specific rules: a wallet is not allowed to use addresses beyond a certain limit before previously generated addresses have been used. This means that, at a given point in a time, a wallet has both a minimum and a maximum number of possible unused addresses. By default, the maximum number of consecutive unused addresses is set to 20.\nTherefore, address management is entirely done by the server and users aren\u0026rsquo;t allowed to fiddle with them. The list of available addresses can be fetched from the server at any time via:\nGET /byron-wallets/{walletId}/addresses\nThis list automatically expands when new addresses become available so that there\u0026rsquo;s always address_pool_gap consecutive unused addresses available (where address_pool_gap can be configured when a wallet is first restored / created).\nusing cardano-addresses Coming soon. "});index.add({'id':7,'href':'/adrestia/docs/installation/','title':"Installation Instructions",'content':"Using Docker (recommended) Docker images are continuously built and deployed on dockerhub under specific tags. Using docker provides the fastest and easiest user experience for setting up the Cardano stack. You should prefer this solution over building from sources unless you have really good reasons not to. The following images are available for each component of the Adrestia architecture:\n   Repository Tags Documentation     inputoutput/cardano-node master, MAJ.MIN.PATCH, latest link   inputoutput/cardano-db-sync master, MAJ.MIN.PATCH, latest link   inputoutput/cardano-graphql master, MAJ.MIN.PATCH, latest link   inputoutput/cardano-rosetta master, MAJ.MIN.PATCH, latest link   inputoutput/cardano-wallet byron, YYYY.MM.DD-byron, latest link    Semantic    Tag Semantic     latest Points to the latest stable image for the corresponding component. This is also the tag to which docker defaults when pulling without an explicit tag. These typically points to latest known release which happens at the end of an iteration cycle. Depending on which project / component, the iteration cycle may vary from 1 to 2 weeks.   MAJ.MIN.PATCH or YYYY.MM.DD Must match actual releases of the corresponding component. Refer to each component release notes to know which release tags are available.   master Points to the very tip of the development branch. This is therefore not recommended for production but can be useful to try out features before they are officially released.    Examples For example, in order to use cardano-node@1.10.0, one can simply run:\ndocker pull inputoutput/cardano-node:1.10.0 Similarly, one can pull cardano-wallet@v2021-08-11 with:\ndocker pull inputoutput/cardano-wallet:2021.8.11 ℹ️ About version compatibility\nFor version compatibility between components, please refer to compatibility matrix on each component main page (e.g. cardano-wallet#latest-releases).\n Docker compose Some components also provide example setup via docker-compose. Those are useful for a quick start or as a baseline for development. See for example cardano-wallet or cardano-graphql.\nPre-compiled Artifacts / Building From Sources In case you prefer using raw binary instead, some components do provide pre-compiled release artifacts for each release. These can be downloaded directly from the github servers, via the UI or using a command-line tool like wget or cURL. For example, one can download a pre-packaged linux binary for cardano-wallet@v2020-04-07 via:\ncurl -L https://github.com/input-output-hk/cardano-wallet/releases/download/v2020-04-07/cardano-wallet-v2020-04-07-linux64.tar.gz | tar xz If you feel brave enough and want to compile everything from sources, please refer to each repository\u0026rsquo;s documentation. As a pre-requisite, you may want to install and configure Nix, stack or cabal depending on your weapon of choice. Build instructions are available on each repository\u0026rsquo;s main README.\n   Repository Releases Linux MacOS Windows     cardano-node releases ✔️ ✔️ ✔️   cardano-db-sync releases ✔️ ✔️ ❌   cardano-submit-api releases ✔️ ✔️ ❌   cardano-graphql releases ✔️ ✔️ ❌   cardano-rosetta releases ✔️ ✔️ ❌   cardano-wallet releases ✔️ ✔️ ✔️    "});index.add({'id':8,'href':'/adrestia/docs/common-use-cases/','title':"Common Use-Cases",'content':""});index.add({'id':9,'href':'/adrestia/docs/common-use-cases/how-to-make-a-transaction/','title':"How to make a transaction",'content':" using cardano-wallet Difficulty: beginner\nRequires:\n 📦 cardano-wallet \u0026gt;= v2020-04-01   Assuming you have already created a wallet, you can send a transaction by using the following endpoint:\nPOST /v2/byron-wallets/{walletId}/transactions\nBehind the scene, the wallet engine will select necessary inputs from the wallet, generate a change address within the wallet, sign and submit the transaction. A transaction can have multiple outputs, possibly to the same address. Note that in Byron, addresses are necessarily base58-encoded (as an enforced convention).\nOnce submitted through the wallet, a can be tracked via:\nGET /v2/byron-wallets/{walletId}/transactions\nWhich returns a list of all transactions for this particular wallet. Optional range filters can be provided. A transaction will go through a succession of states, starting as “Pending”. If a transaction stays pending for too long (because rejected by a mempool, or because lost in translation due to multiple chain switches), users may decide to forget it using:\nDELETE /v2/byron-wallets/{walletId}/transactions/{transactionId}\nFor more information about transactions lifecycle, have a look at this wiki page.\nusing cardano-transactions Difficulty: advanced\nRequires:\n 📦 cardano-transactions \u0026gt;= 1.0.0 📦 cardano-submit-api \u0026gt;= 2.0.0 OR cardano-wallet \u0026gt;= v2020-04-01   Alternatively, cardano-wallet and cardano-submit-api allows clients to submit already signed and serialized transactions as a raw bytes blob. This can be done by submitting such serialized data as an application/octet-stream to either of:\n cardano-wallet: POST /v2/proxy/transactions cardano-submit-api: POST /api/submit/tx  In this scenario, the server engine will verify that the transaction is structurally well-formed and forward it to its associated node. If the transaction belongs to a known wallet, it will eventually show up in the wallet your wallet.\nSuch transactions can be constructed from raw data using either cardano-transactions library or command-line interface. Examples and documentation excerpts are available on the corresponding Github repository.\n "});index.add({'id':10,'href':'/adrestia/docs/key-concepts/','title':"Key Concepts",'content':""});index.add({'id':11,'href':'/adrestia/docs/api-references/','title':"API References",'content':"Components    Component Link     cardano-wallet https://input-output-hk.github.io/cardano-wallet/api/edge   cardano-graphql https://input-output-hk.github.io/cardano-graphql/   cardano-rosetta https://github.com/input-output-hk/cardano-rosetta/tree/master/docs   cardano-submit-api     About cardano-wallet\nCardano-wallet comes with a command-line interface that can be used as a quick alternative to cURL or wget to interact with a server running on localhost. Every endpoint of the API is mapped to a corresponding command which often offers a better user experience than directly interacting with the API as a human (API are for programs, command-lines are for humans).\nFor example, restoring a wallet goes normally through POST /byron-wallets, or can be done interactively with\n$ cardano-wallet wallet create MyWallet The command line also provides some useful helpers like a command to generate mnemonic sentences, or doing key derivation. For more details, see the wallet command-line user manual.\n Libraries    Library Haskell JavaScript     cardano-addresses https://input-output-hk.github.io/cardano-addresses/haddock/ https://input-output-hk.github.io/cardano-addresses/typescript/   cardano-transactions https://input-output-hk.github.io/cardano-transactions/haddock/ Soon available.   cardano-coin-selection https://input-output-hk.github.io/cardano-coin-selection/haddock/ Soon available.   bech32 https://input-output-hk.github.io/bech32/haddock/ See https://github.com/bitcoinjs/bech32    About cardano-transactions\nIn addition to the low-level library, cardano-transactions also provides a command-line interface (cardano-tx) to construct transactions directly in the terminal. Check out the repository\u0026rsquo;s documentation and examples to see example usage.\n "});index.add({'id':12,'href':'/adrestia/docs/faq/','title':"FAQ",'content':" Why aren\u0026#39;t my unused addresses imported when I restore a wallet? ...  This is by virtue of the blockchain. An unused address is by definition unused. Meaning that is doesn\u0026rsquo;t exist on the chain and only exists locally, in the context of the software that has generated it. Different software may use different rules to generate addresses. For example in the past, cardano-sl wallets used a method called random derivation where addresses were created from a root seed and a random index stored within the address itself. Because these indexes were random, it was not possible to restore randomly generated addresses which hadn\u0026rsquo;t been used on chain yet!\nMore recently, cardano-wallet has been using sequential derivation which follows a very similar principle with the major difference that indexes are derived in sequence, starting from 0. Following this method, wallets aren\u0026rsquo;t allowed to pre-generate too many addresses in advance. As a consequence, it is now possible to restore a wallet across many machines while keeping a very consistent state.\n    I’ve noticed that other blockchains create accounts for wallets? ...  There are two sides to this question. Either, you are referring to accounts as in Ethereum accounts, or you may refer to accounts of hierarchical deterministic wallets.\nIn the first scenario, assets in the form of accounts are only supported in the Shelley era of Cardano and only for a specific use-case: rewards. Rewards are indeed implicitely published on the blockchain to mitigate the risk of flooding the network at the end of every epoch with rewards payouts! Hence, each core node keeps track of the current value of each reward account in a Ledger. Money can be withdrawn from this account and is then turned as a UTxO. Please note that funds can never be manually sent to a reward account. The creation of a reward account is done when registering a staking key, via a specific type of transaction.\nIn the second case, please refer to the HD wallets section in the Key concepts. Cardano wallets typically follow an HD tree of derivation as described in this section.\n    It seems like I have to install and configure many APIs and libraries, what is the fastest and most simple way to do this at once? ...  🐳 docker is your friend here! Every component is packaged as docker images. Releases are tagged and the very edge is always accessible. See the various docker guides on the components\u0026rsquo; repository, and also how to compose services using docker-compose.     Is there a reason why I would have to build from src? ...  If you intend to contribute to Cardano by making code changes to one of the core components, then yes. We recommend using stack for a better developer experience.\nIf you only intend to use the services as-is then, using either the pre-compiled release artifacts for your appropriate platform or a pre-packaged docker image is preferable.\n    Where is the faucet and do I get test ADA? ...   https://testnets.cardano.org/en/testnets/cardano/tools/faucet/     "});index.add({'id':13,'href':'/adrestia/docs/','title':"Docs",'content':""});})();